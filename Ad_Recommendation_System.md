🧭 一、广告推荐系统的总体目标

核心目标： 在有限的曝光资源下，让每一次展示都能最大化平台收益（eCPM）和用户体验。

eCPM 公式通常为：

𝑒𝐶𝑃𝑀 = 𝐵𝑖𝑑 × 𝑝𝐶𝑇𝑅 × 𝑝𝐶𝑉𝑅 × 1000

其中：
Bid：广告主出价
pCTR：点击率预测（是否会点）
pCVR：转化率预测（点后是否会转化）

整个系统的工作流程就是围绕这三个量展开的。

🧩 二、整体链路结构（从请求到展示）
用户请求 → 候选广告召回 → 特征提取 → CTR/CVR 预测与排序
→ 出价调整（oCPM） → 过滤 & 决策 → 广告曝光与反馈
→ 日志采集 → 训练样本生成 → 模型更新与监控




1️⃣ 用户请求（Ad Request）

当用户打开 App Store、Browser 或 Push 场景时，系统会发出一个广告请求（Request）。

包含的信息：用户 ID、上下文（时间、地理位置、设备）、页面类型、展示位（slot）等。

这一步会触发终端侧 SDK 与服务器交互。

2️⃣ 候选广告召回（Recall）

系统需要从海量广告中挑出“可能相关”的一小部分候选。

常见召回策略：

向量召回（Embedding Recall）：利用用户、广告向量相似度（如 ANN、FAISS）。

基于规则或人群包：根据地域、性别、兴趣标签。

多路召回：热门广告召回 + 新广告召回 + 精准召回。

通常召回上万条广告，供后续排序使用。

🚀 召回阶段的目标是高召回率（Recall），宁滥勿缺。

3️⃣ 特征提取（Feature Engineering）

召回后的候选广告需要拼接用户、广告、上下文等多种特征。

用户侧：年龄、性别、兴趣、历史点击。

广告侧：广告 ID、出价、类目、创意文本。

上下文：时间、位置、设备类型。

这一阶段输出统一的特征向量输入模型。

🧱 特征工程的质量直接决定模型效果。
通常由 Spark/Airflow 流水线完成。

4️⃣ 排序阶段（CTR/CVR 模型预测）

这里是广告算法工程师的主战场。

CTR 模型：预测用户看到后是否会点击。
常用模型：Wide&Deep、DeepFM、DCN、DIN。

CVR 模型：预测点击后是否会转化。
常用模型：ESMM（Multi-Task）或 PLE（多专家学习）。

预估收益（eCPM）计算：

𝑒𝐶𝑃𝑀 = 𝐵𝑖𝑑 × 𝑝𝐶𝑇𝑅 × 𝑝𝐶𝑉𝑅
或在预算控制下使用：
𝑜𝐶𝑃𝑀 = 𝐵𝑖𝑑 × 𝑝𝐶𝑇𝑅 × 𝑝𝐶𝑉𝑅 × 𝐴𝑑𝑗𝑢𝑠𝑡𝑚𝑒𝑛𝑡

🔧 这部分的优化就是项目重点：

提升 CTR/CVR 准确度；

做任务分解、偏差修正；

结合业务指标（ROI、eCPM）优化整体排序。

5️⃣ 出价调整与拍卖机制（Bidding & Auction）

系统根据预测值动态调整广告出价（Smart Bid）。

一般使用二价拍卖（GSP）机制：
赢家付第二高价，确保公平。

通过“预算平滑”（Budget Pacing）控制广告主日预算消耗节奏。


6️⃣ 过滤与展示（Filtering & Serving）

最终根据规则过滤（违规、频控、黑名单等）。

展示广告 → 用户行为反馈（曝光、点击、转化）会实时回流。

7️⃣ 日志采集与训练样本生成

所有行为日志会进入离线存储，用于后续训练：

训练样本：曝光 → 点击/未点击；

CVR 样本：点击 → 转化/未转化。

离线数据经过特征提取、采样、标注形成训练集。

💾 工具：Spark / Hive / Airflow。

8️⃣ 模型训练、上线与监控

离线训练模型 → 模型评估（AUC、NDCG、eCPM）；

线上服务（TensorFlow Serving / TorchServe）；

指标监控：

模型效果：AUC、Loss、CTR lift。

业务指标：eCPM、ROI、消耗、曝光稳定性。

漂移检测（Feature Drift / Data Drift）。


🌐 三、广告推荐系统的“核心循环”

“广告推荐系统本质是一个闭环：
数据采集 → 模型训练 → 在线投放 → 行为反馈 → 再训练。
每一次曝光与点击，都是下一次优化的输入。”

📈 四、延伸：指标目标与平衡
目标类型	指标	平衡点
用户体验	CTR, dwell time, relevance	避免过度广告化
商业收益	eCPM, ROI, conversion value	提高广告主收益
平台稳定性	pacing, delivery fairness	控制预算、曝光分布
模型表现	AUC, NDCG, calibration	预测准确性
